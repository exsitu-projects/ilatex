import * as path from "path";
import { SourceFile } from "./SourceFile";

export type CodeMappingID = number;

export class MissingMappingFieldError {}

export class CodeMapping {
    readonly type: string;
    readonly sourceFile: SourceFile;
    readonly lineNumber: number;
    readonly id: CodeMappingID;

    private constructor(
        type: string,
        sourceFile: SourceFile,
        lineNumber: number,
        id: number
    ) {
        this.type = type;
        this.sourceFile = sourceFile;
        this.lineNumber = lineNumber;
        this.id = id;
    }

    static fromLatexGeneratedMapping(
        mappingAsString: string,
        mainSourceFileDirectoryPath: string,
        sourceFiles: SourceFile[]
    ): CodeMapping {
        const mappingEntries = mappingAsString
            .split("\n")
            .map(singleLine => {
                const firstSpaceIndex = singleLine.indexOf(" ");
                return {
                    key: singleLine.substring(0, firstSpaceIndex),
                    value: singleLine.substring(firstSpaceIndex + 1),
                };
            });

        function getEntryValueOrFail(key: string): string {
            const entry = mappingEntries.find(entry => entry.key === key);
            if (!entry) {
                console.error(`No mapping entry "${key}" could be found in the given entry.`);
                throw new MissingMappingFieldError();
            }

            return entry.value;
        }

        // Paths generated by LaTeX can sometimes be relative
        // and/or contain '.' directories, useless successive slashes, etc.
        // We therefore transform the path to ensure all source files
        // are created using a normalised, absolute path.
        const pathEntry = getEntryValueOrFail("path");
        
        // if (path.isAbsolute(pathEntry)) {

        // }
        // const normalisedAbsolutePath = path.join(
        //     mainSourceFileDirectoryPath,
        //     path.normalize(pathEntry)
        // );

        const normalisedAbsolutePath = path.isAbsolute(pathEntry)
                                     ? path.normalize(pathEntry)
                                     : path.join(
                                           mainSourceFileDirectoryPath,
                                           path.normalize(pathEntry)
                                       );

        const sourceFile = sourceFiles.find(sourceFile =>
            sourceFile.absolutePath === normalisedAbsolutePath
        ) ?? new SourceFile(normalisedAbsolutePath);

        return new CodeMapping(
            getEntryValueOrFail("type"),
            sourceFile,
            parseInt(getEntryValueOrFail("line")),
            parseInt(getEntryValueOrFail("id"))
        );
    }
}