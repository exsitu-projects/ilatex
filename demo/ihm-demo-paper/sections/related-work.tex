\section{Travaux connexes}
\label{sec:travaux-connexes}

Nous présentons les divers travaux ayant inspiré le concept de RII et le prototype \iLaTeX{} : les documents composés d'éléments interactifs ou programmables ; les langages, paradigmes et environnements de programmation non-textuels ; et les représentations intermédiaires utilisées dans d'autres domaines.


\subsection{Éditeurs de documents \LaTeX{}}

\LaTeX{} est un langage de description de document créé par Leslie Lamport en 1984~\cite{lamport1994latex} qui repose sur \TeX{}, un système de composition de document développé par Donald Knuth à la fin des années 1970~\cite{knuth1984texbook}.
Aujourd'hui, il demeure un choix courant pour la rédaction de publications académiques et techniques, et ce en dépit de la difficulté à l'utiliser --- y compris pour des utilisateurs experts, qui peuvent \og subir une perte de productivité lorsque \LaTeX{} est utilisé, par rapport à d'autres systèmes de préparation de{} documents \fg~\cite{knauff2014efficiency}.
Étant donné que \LaTeX{} est un langage de commandes, la plupart des éditeurs de documents \LaTeX{} ressemblent plus à des éditeurs de code qu'à des éditeurs WYSIWYG --- incluant des fonctionnalités telles que la coloration syntaxique et l'auto-complétion.
Certains éditeurs \LaTeX{} essaient d'offrir une expérience se rapprochant de celle des éditeurs WYSIWYG ; mais à notre connaissance, soit ils ne fournissent qu'un formatage de base du code source (\eg{} AUC\TeX{}\footnote{\url{https://www.gnu. org/software/auctex/}}, le mode \emph{rich text} d'Overleaf\footnote{\url{https://www.overleaf.com}}), soit ils fournissent une interface entièrement WYSIWYG qui masque le code et ne prend en charge qu'un ensemble limité de fonctionnalités (\eg{} Compositor\footnote{\url{https://compositorapp.com/}}).
Les éditeurs LyX\footnote{\url{https://www.lyx.org/}} et TeXmacs\footnote{\url{https://www.texmacs.org}} proposent de représenter un document entier sous une forme graphique intermédiaire mettant en avant sa structure et son contenu plutôt que son rendu final --- un paradigme souvent appelé \emph{What You See Is What You Mean}.
Néanmoins, à notre connaissance, aucun éditeur de ce type ne permet de manipuler directement le code \LaTeX{} (au delà de l'import/export au format \LaTeX{} et de l'insertion de courts morceaux de code, \eg{} une formule mathématique écrite en \LaTeX{}).
Plusieurs solutions permettent de pré-visualiser le rendu de certains éléments isolés (\eg{} une formule mathématique, une figure), d'animer la génération du document (\eg{} Gliimpse~\cite{dragicevic2011gliimpse}), ou encore d'associer à chaque élément du PDF généré une position dans le code, et inversement (\eg{} SyncTeX~\cite{laurens2008direct}) ; mais aucune d'entre elles ne permet de modifier le code plus facilement.

\iLaTeX{} se distingue des éditeurs de documents \LaTeX{} existants en offrant un accès immédiat et complet au code \LaTeX{} et au PDF généré (à la façon des éditeurs de code comme TeXstudio) tout en permettant de visualiser et de manipuler le code de certains éléments à travers des représentations plus adaptées plus ou moins similaires à celles imposées par des éditeurs comme LyX et Compositor.



\subsection{Documents interactifs}

Dans son essai de 2011, \emph{Explorable Explanations}\footnote{\url{http://worrydream.com/ExplorableExplanations/}}, Bret Victor plaide en faveur de documents plus interactifs, dans lesquels les utilisateurs pourraient dynamiquement modifier des valeurs et observer comment d'autres informations évoluent.
Ce principe est repris par les multivers de Dragicevic~\etal{}~\cite{dragicevic2019increasing}, qui démontrent l'intérêt de permettre aux lecteurs d'explorer différentes façons d'analyser et de visualiser des données expérimentales.
Afin de rendre la conception de documents interactifs plus accessible aux non-programmeurs, Conlen~\etal{} présentent Idyll~\cite{conlen2018idyll}, un langage de balises conçu pour les journalistes.
Afin d'outrepasser le manque d'interactivité lié aux limites de certains formats de fichiers, Chameleon~\cite{masson2020chameleon} propose d'identifier certains contenus sur l'écran à l'aide de techniques de vision par ordinateur afin d'y surimprimer des versions animées ou interactives du même contenu.

En permettant de modifier le code source des documents en interagissant avec le PDF, \iLaTeX{} exploite la notion de document interactif.
Cependant, contrairement aux travaux présentés ci-dessus, il ne s'agit pas de produire un document PDF interactif pour les \emph{lecteurs}, mais de rendre son édition plus interactive pour les \emph{auteurs}.



\subsection{Programmation de documents}

L'idée de mélanger rédaction de documents et programmation est apparue avec le développement de nouveaux langages de description de document dans les années 1970.
Elle s'est poursuivie par la promotion de concepts tels que le \emph{literate programming}~\cite{knuth1984literate} de Knuth et la conception de langages et de paradigmes de programmation centrés sur l'humain (tels que Smalltalk~\cite{goldberg1983smalltalk80}) dans les années 1980.
Cette idée a depuis été remise au goût du jour par la popularité croissante des \emph{computational notebooks} comme Jupyter\footnote{\url{https://jupyter.org/}}, largement adoptés par des communautés de sciences des données.
Les \emph{notebooks} permettent de faire cohabiter des cellules dont le contenu est rédigé par les auteurs (texte, code) avec des cellules dont le contenu est généré par l'exécution d'un programme.
Bien que ces dernières soient traditionnellement statiques, Kery~\etal{}~\cite{kery2020future} présentent plusieurs pistes pour rendre celles-ci plus interactives --- par exemple pour les tableaux de données ({Figure~\ref{fig:interactive-dataframe-exemple}}).
Wrex~\cite{drosos2020wrex} permet de synthétiser le code permettant d'insérer et de remplir une nouvelle colonne à partir d'un ou plusieurs exemples fournis interactivement par les utilisateurs via la représentation d'un tableau de données.

\iLaTeX{} inclut un éditeur de code et permet donc naturellement d'utiliser toutes les fonctionnalités de programmation de document offertes par \LaTeX{}.
Les représentations intermédiaires qu'il inclut constituent un moyen supplémentaire de
visualiser et de manipuler le code, au même titre que celles développées pour les \emph{notebooks} sus-mentionnés.

\begin{figure}
    \centering
    \iincludegraphics[width=0.4\textwidth]{interactive-dataframe.png}
    \caption{Déplacer une colonne du tableau génère le code qui implémente la modification (adapté de Kery \etal~\cite{kery2020future}).}
    \Description{L'image contient deux étapes d'une même interaction : cliquer et déplacer la colonne d'un tableau (représentant un dataframe dans un notebook) pour l'insérer entre deux autres colonnes. La seconde étape montre le résultat une fois la colonne déplacée, et le tableau est désormais précédé d'une cellule contenant un commentaire "generated code" et quatre lignes de code Python qui extraient la colonne déplacée, puis la réinsèrent à sa nouvelle position.}
    \label{fig:interactive-dataframe-exemple}
\end{figure}



\subsection{Programmation non-textuelle}

Depuis les années 1980, des langages de programmation visuels particulièrement adaptés au traitement de signaux multimédia tels que Max\footnote{\url{https://cycling74.com/products/max}} et Pure Data\footnote{\url{https://puredata.info/}} ont été développés.
La syntaxe graphique simple et la manipulation directe des blocs qui composent les programmes rendent ces langages particulièrement accessibles à des utilisateurs sans formation en programmation.
Cela pourrait expliquer pourquoi ce type de langage continue d'être utilisé aujourd'hui.
Il a par exemple été choisi pour concevoir Dynamic Brushes~\cite{jacobs2018extending}, un système de programmation du comportement d'un pinceau numérique destiné à des illustrateurs.
D'autres langages visuels ont également été largement adoptés à des fins éducatives (\eg{} Scratch~\cite{resnick2009scratch}).
Néanmoins, certains chercheurs affirment qu'ils pourraient également être utiles pour des professionnels~\cite{bau2017learnable}.
Dans cette optique, Droplet\footnote{\url{http://droplet-editor.github.io/}} et les \emph{frame-based editors}~\cite{brown2016framebased} illustrent deux façons de 
faire fusionner la richesse des langages textuels avec la manipulation directe des langages à blocs.

La programmation non-textuelle peut également prendre la forme de nouveaux genres d'éditeurs de code.
Plusieurs travaux proposent d'aider les programmeurs à visualiser l'état courant du programme en augmentant des éditeurs de code traditionnels avec des données brutes~\cite{lerner2020projection} ou visualisées~\cite{hoffswell2018augmenting}.
Python Tutor~\cite{guo2013online} affiche par exemple les structures de données utilisées sous une forme schématique à des fins éducatives.
D'autres travaux portent plutôt sur de nouvelles façons d'interagir avec le code.
Sketch-n-Sketch~\cite{hempel2019sketchnsketch} est un éditeur expérimental permettant de programmer une image vectorielle en utilisant un langage fonctionnel et de modifier son code en interagissant directement avec le SVG généré.
Il illustre l'idée du \emph{output-directed programming} de Chugh~\cite{chugh2016programmatic}, qui consiste à éditer le code source d'un programme en manipulant directement sa sortie graphique.

Les représentations intermédiaires de \iLaTeX{} sont inspirées de ces différentes façons de penser le code autrement que comme du texte brut --- et plus particulièrement de l'approche de Sketch-n-Sketch.
Ces représentations permettent de s'affranchir de la compilation du document pour visualiser le moindre changement tout en permettant de donner forme à des abstractions invisibles dans le code et effacées dans le document généré.



\subsection{Représentations intermédiaires}

La représentation la plus appropriée du code d'un programme ou d'une description de document peut se situer entre le code brut et la sortie du programme : on parle alors de représentation \emph{intermédiaire}.
Si celle-ci permet de modifier le code qu'elle représente, elle est de surcroît \emph{interactive} ({Figure \ref{fig:intermediate-representations-examples}}).
Barista~\cite{ko2006barista}, Envision~\cite{asenov2014envision} et JetBrains MPS\footnote{\url{https://www.jetbrains.com/mps/}} sont différents éditeurs de code capables d'afficher certains éléments de langages textuels sous une forme structurée (\eg{}~organiser le code sous forme d'un tableau) ou graphique (\eg{} dessiner les symboles d'une expression mathématique).
Graphite~\cite{omar2012active} permet de générer le code d'une couleur à partir d'une palette interactive, tandis que Clint~\cite{zinenko2014clint} permet de modifier le code de boucles imbriquées afin d'améliorer les performances d'un programme à travers la manipulation de diagramme interactifs.

\iLaTeX{} a pour but de fournir des représentations intermédiaires de morceaux de code \LaTeX{} qui gagnent à pouvoir être visualisés et manipulés autrement que sous forme textuelle, de la même manière que des systèmes tels que Barista et Clint le font pour des langages de programmation et des paradigmes plus traditionnels.
En outre, \iLaTeX{} permet d'afficher ces visualisations à proximité des éléments correspondants du PDF généré, renforçant ainsi les liens entre les deux ; tandis que les exemples donnés ci-dessus les affichent généralement uniquement à proximité du code concerné.

\begin{figure*}[ht]
    \center
    \subfigure[Éditeur d'animation de Mozilla Firefox]{%
        \centering\iincludegraphics[width=0.4\textwidth]{firefox-anim-editor.png}
        \label{subfig:firefox-anim-editor}
    }
    \subfigure[Éditeur de boucles imbriquées de Clint (d'après Zinenko \etal~\cite{zinenko2015manipulating})]{%
        \centering\iincludegraphics[width=0.4\textwidth]{clint.png}
        \label{subfig:clint}
    }
    \caption{Exemples de représentations intermédiaires interactives. \psubref{subfig:firefox-anim-editor} La manipulation des poignées pour modifier la courbe met à jour les paramètres numériques de la propriété CSS (affichée en dessous). \psubref{subfig:clint} L'inclinaison du polygone transforme le code C++ (affiché au dessus) pour refléter la façon dont les opérations doivent être parallélisées selon le nouveau diagramme.}
    \Description{Deux interfaces contenant des représentations intermédiaires. L'interface (a) contient une dizaine de miniatures de courbes représentant des possibilités de progression d'animation, ainsi que la courbe représentant la progression courante avec deux poignées permettant de la déformer. L'interface (b) contient deux graphiques 2D (avant et après transformation). Chaque graphique contient un ensemble de points (itérations) relié par des flèches représentant leurs dépendances (contraintes sur l'ordre des calculs). Le passage d'un graphique à l'autre déforme le polygone qui contient tous les points.}
    \label{fig:intermediate-representations-examples}
\end{figure*}